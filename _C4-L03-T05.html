<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.11">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Oren Bochman">

<title>c4-l03-t05</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="_C4-L03-T05_files/libs/clipboard/clipboard.min.js"></script>
<script src="_C4-L03-T05_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="_C4-L03-T05_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="_C4-L03-T05_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="_C4-L03-T05_files/libs/quarto-html/popper.min.js"></script>
<script src="_C4-L03-T05_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="_C4-L03-T05_files/libs/quarto-html/anchor.min.js"></script>
<link href="_C4-L03-T05_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="_C4-L03-T05_files/libs/quarto-html/quarto-syntax-highlighting-09b140d2d032adf2aedb8b099be3ee13.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="_C4-L03-T05_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="_C4-L03-T05_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="_C4-L03-T05_files/libs/bootstrap/bootstrap-068d5c994a6974d0eba00eca07de929a.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Oren Bochman </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<!-- transcript of https://www.coursera.org/learn/bayesian-statistics-time-series-analysis/lecture/EILYM/filtering -->
<p><mark>I will now discuss Bayesian inference in the case of the normal dynamic linear model where both the observational variance and the system variance are known. We will talk about filtering equations, smoothing equations and also forecasting in this setting using Bayesian approach.</mark></p>
<p><del>So recall we are working with a model that looks like this: … And then this is my first equation, the observation equation and I have a system equation that looks like this.</del></p>
<p><del>We are going to assume that <span class="math inline">\(V_t\)</span> and <span class="math inline">\(W_t\)</span> are known for every t. And we also know what the <span class="math inline">\(F_t\)</span>’s and the <span class="math inline">\(G_t\)</span>’s are here. So the response is a uni-dimensional <span class="math inline">\(y_t\)</span> and then I have, say, <span class="math inline">\(\theta_t\)</span> is a vector of a given dimension, depending on the structure of the model.</del></p>
<p><mark>We are interested in performing <strong>Bayesian inference</strong> in this setting and we talked about different kinds of distributions</mark></p>
<ul>
<li><p><mark>One is the <strong>filtering distribution</strong> that allows us to update the distribution of <span class="math inline">\(\theta_t\)</span> as we receive observations and information over time.</mark></p></li>
<li><p><mark>The other one is <strong>smoothing equations</strong> that allows us to just revisit the past once we have observed a chunk of data.</mark></p></li>
</ul>
<p><del>So I will be talking about those and also smoothing.</del></p>
<p><del>In a Bayesian setting, you have to set a prior distribution.</del> <mark>We will work with the prior distribution that is conjugate.</mark></p>
<p><del>In this case I have to begin with distribution at time zero. So before I know, I have seen any data at all,</del> <mark>I have this prior distribution. <span class="math inline">\(D_0\)</span> stands for the information that I have before collecting any data. And we are going to assume, That this <span class="math inline">\(\theta_0\)</span> follows a normal distribution with <span class="math inline">\(m_0\)</span> mean and variance covariance matrix <span class="math inline">\(C_0\)</span>. So these are also specified when you’re working with this model.</mark></p>
<p>So we assume that this <span class="math inline">\(m_0\)</span> and <span class="math inline">\(C_0\)</span> is known.</p>
<p><mark>Once we have this setting using these equations, we can obtain the filtering equations.</mark></p>
<p>So the first assumption is going to be that we have, a structure.</p>
<p>So for <span class="math inline">\(\theta_{t -1} \mid \mathcal{D}_{t-1}\)</span> is going to have this normal structure which is going to happen basically because we’re using this conjugate prior. And because we have normal structure in the model, is going to lead to the following distribution. So the first one is the prior at time <span class="math inline">\(t\)</span>.</p>
<p><mark>So if I want to think about why my distribution for the t is given the information I have up to <span class="math inline">\(t-1\)</span>, I can look at the equations of the model and use this second equation. And by looking at this equation, if I condition on the information I have up to <span class="math inline">\(t-1\)</span>, I can see that, say, <span class="math inline">\(\theta_t\)</span> is written as a linear function of, <span class="math inline">\(\theta_{t -1}\)</span> and I have the assumption of normality here.</mark></p>
<p><del>Therefore, say, <span class="math inline">\(\theta_t\)</span> going to follow a normal distribution with some mean and some variance. So now we’re going to compute this mean and this variance using this equation. So if you think about the expected value of <span class="math inline">\(\theta_t\)</span>, given <span class="math inline">\(D_{t -1}\)</span>, that’s just going to be <span class="math inline">\(G_t\)</span> is a constant here. So I have my <span class="math inline">\(G_t\)</span> and then I have expected value of <span class="math inline">\(\theta_{t -1}\)</span> given <span class="math inline">\(G_{t -1}\)</span> plus expect the value of this <span class="math inline">\(\omega_t\)</span>.</del></p>
<p>But <span class="math inline">\(\omega_t\)</span> is a zero mean, normally distributed quantity, so it’s just going to be zero. Using the assumption that I have this structure, then I have that the <span class="math inline">\(\mathbb{E}[\theta_t \mid \mathcal{D}_{t -1}] = G_t \times m_{t-1}\)</span>. We’re going to call this quantity <span class="math inline">\(a_t\)</span>, so we have here <span class="math inline">\(a_t\)</span>. For the variance covariance matrix, then we just have to compute, do the same type of operation. And again, we can use this equation and see that we obtain this <span class="math inline">\(G_t\)</span> variance of <span class="math inline">\(\theta_{t-1} \mid \mathcal{D}_{t -1} G_t'\)</span>. And then we have now the variance of the omega, the variance of the omega is just <span class="math inline">\(W_t\)</span>. So we have <span class="math inline">\(G_t = C_{t -1} G_t' + W_t\)</span>. So we can call this quantity <span class="math inline">\(R_t\)</span> and just have the form of this prior distribution at time <span class="math inline">\(t\)</span>.</p>
<p>I can now think about another distribution which is the distribution of <span class="math inline">\(y_t \mid \mathcal{D}_{t-1}\)</span>. So this is the so called one-step ahead, Forecast, And in the one-step ahead forecast again is a similar type of structure. So now we’re going to use the first equation rather than the second equation and we see that <span class="math inline">\(y_t\)</span> is written in terms of a linear function of <span class="math inline">\(\theta_t\)</span>. And we have also the Gaussian in assumption here. So again the <span class="math inline">\(y_t\)</span> is going to be normally distributed, And we just have to compute the mean and the variance for this <span class="math inline">\(y_t\)</span>. So using the first equation, we have the expected value of <span class="math inline">\(y_t\)</span> given <span class="math inline">\(D_{t -1}\)</span> is just <span class="math inline">\(F_t' \mathbb{E}[\theta_t \mid D_{t -1}]\)</span>. And we computed this before, so this is, again, the expected value of <span class="math inline">\(\theta_t\)</span> given <span class="math inline">\(D_{t -1}\)</span> is what we computed here. So this is to be <span class="math inline">\(F_t' a_t\)</span>. And we are going to call this little <span class="math inline">\(f_t\)</span>. Then, for the variance, Again, we use this equation, we have this component, so we are going to get <span class="math inline">\(F_t' R_t F_t + D_t\)</span>. And I’m going to call this <span class="math inline">\(q_t\)</span>. So my final distribution, the one-step ahead forecast distribution, tells me that this follows a normal <span class="math inline">\(f_t q_t\)</span>. The next equations we are going to discuss are the equations that tell me about what is the distribution of <span class="math inline">\(\theta_t\)</span> once we incorporate the information provided by <span class="math inline">\(y_t\)</span>. The next distribution is the posterior of <span class="math inline">\(\theta_t\)</span> given <span class="math inline">\(D_t\)</span>. So that’s, <span class="math inline">\(\theta_t\)</span> given <span class="math inline">\(D_t\)</span>. And we can write <span class="math inline">\(D_t\)</span> as whatever information we have at time <span class="math inline">\(t- 1\)</span>. And the new data point with this just <span class="math inline">\(y_t\)</span>. So we just want to update the distribution of <span class="math inline">\(\theta_t\)</span> given that we have received this additional data point at time <span class="math inline">\(t\)</span>. There are two ways of computing this distribution. One uses normal theory, the other one uses Bayes’ theorem. And you obtain that the distribution of <span class="math inline">\(\theta_t\)</span> given <span class="math inline">\(D_t\)</span> is going to be a normal, with mean we call it <span class="math inline">\(m_t\)</span> and variance <span class="math inline">\(C_t\)</span>. We will see how to obtain this distribution or the moments of this distribution using normal theory.</p>
<blockquote class="blockquote">
<blockquote class="blockquote">
<p>So, again, we can write down, if we think about just combining the vector <span class="math inline">\(\theta_t\)</span> with the observation</p>
</blockquote>
</blockquote>
<p><span class="math inline">\(Y_t\)</span> given <span class="math inline">\(D_{t -1}\)</span>, right? We have information about <span class="math inline">\(\theta_t \mid t-1\)</span>. That’s the prior for <span class="math inline">\(\theta_{ta,t}\)</span>, based on the information at <span class="math inline">\(t -1\)</span>. And then we also computed before the one step ahead forecast distribution for <span class="math inline">\(y_t| \mathcal{D}_{t -1}\)</span>. So we know that when we combine these two in a single vector, we’re going to have a multivariate normal distribution and the first component is going to be <span class="math inline">\(a_t\)</span>. The second component is what we have called <span class="math inline">\(F_t\)</span>, so that’s the mean. And then for the covariance matrix. We’re going to have now, what goes here is just the variance of <span class="math inline">\(\theta_t\)</span> given <span class="math inline">\(D_{t -1}\)</span>, which we have called <span class="math inline">\(R_t\)</span>. What goes here is the variance of <span class="math inline">\(y_t \mid \mathcal{D}_{t -1}\)</span> and we have called this <span class="math inline">\(q_t\)</span>. And now we have to compute the covariance between <span class="math inline">\(\theta_t\)</span> and <span class="math inline">\(y_t\)</span>, and that goes here. And the covariance between <span class="math inline">\(y_t\)</span> and <span class="math inline">\(\theta_t\)</span>, which is just the transpose of that, is going to go here. So if I think about computing the covariance of <span class="math inline">\(\theta_t\)</span> and <span class="math inline">\(y_t \mid \mathcal{D}_{t -1}\)</span>, I can write <span class="math inline">\(y_t\)</span> using the first equation here as a function of <span class="math inline">\(\theta_t\)</span>. That’s going to give us, <span class="math inline">\(F_t' \theta_t + v_t\)</span> given <span class="math inline">\(D_{t -1}\)</span>. And in this one we can see that this is going to give us basically the variance of <span class="math inline">\(\theta_t\)</span> given <span class="math inline">\(D_{t -1}\)</span> and then multiplied by <span class="math inline">\(F_t' F_t\)</span> which gives me the <span class="math inline">\(F_t\)</span>. So this is going to be variance of <span class="math inline">\(\theta_t\)</span> given <span class="math inline">\(D_{t -1}\)</span> times <span class="math inline">\(F_t\)</span>. And then there is a term that combines the <span class="math inline">\(\theta_t\)</span> with the noise but they are independent, so the covariance is going to be zero. So this one is simply going to be my <span class="math inline">\(R_t F_t\)</span>, so this goes here, And what goes here is just the covariance of <span class="math inline">\(y_t\)</span> with <span class="math inline">\(\theta_t\)</span> or the transpose of this. So this is going to give me <span class="math inline">\(F_t' R_t'\)</span>, but <span class="math inline">\(R_t\)</span> is a covariance matrix, so <span class="math inline">\(R_t' = R_t\)</span>. So now I have my full multivariate distribution and I can use properties of the multivariate distribution to compute the distribution of, <span class="math inline">\(\theta_t\)</span>, given <span class="math inline">\(y_t\)</span> and <span class="math inline">\(D_{t -1}\)</span>. So that’s going to be a conditional distribution, I’m going to condition on the <span class="math inline">\(y_t\)</span>. And when I combine <span class="math inline">\(y_t\)</span> and <span class="math inline">\(D_{t -1}\)</span> that gives me just the information up to time <span class="math inline">\(t\)</span>. So we are interested in just finding, say, <span class="math inline">\(\theta_t\)</span> given <span class="math inline">\(y_t\)</span> and <span class="math inline">\(D_{t -1}\)</span> which is the same as <span class="math inline">\(\theta_t\)</span> given <span class="math inline">\(D_t\)</span>. We partition the normal distribution in this way, so I can just think about this is the first component and then I have these different pieces in my covariance matrix. And we know from normal theory that if we have a distribution, if we have a vector that is partitioned into vectors here where they are normally distributed. And I have my mean partition here and let’s say I have one component here, Then we know that if I wanted to compute the distribution of <span class="math inline">\(X_1\)</span> conditional on <span class="math inline">\(X_2\)</span>, that’s going to give me normal, let’s say <span class="math inline">\(\alpha^*\)</span>. And let’s call this one the <span class="math inline">\(\sigma^*\)</span>, where <span class="math inline">\(\alpha^*\)</span> is going to be my <span class="math inline">\(\alpha_1 + \sigma_{12}^{-1}\)</span>. And then I have <span class="math inline">\(_1 - \alpha_2\)</span> and then I have my <span class="math inline">\(\sigma^*\)</span>. And this one gives me my <span class="math inline">\(\sigma_{11} - \sigma_{21}\)</span>. So this is a result from normal theory. So if I want my conditional distribution of <span class="math inline">\(X_1\)</span> given <span class="math inline">\(X_2\)</span> I can apply these equations. So we notice we have the same type of structure here. If I partition my vector and in <span class="math inline">\(\theta_t\)</span> and <span class="math inline">\(y_t\)</span>. And now I condition on, I take the distribution of <span class="math inline">\(\theta_t\)</span> conditioning on <span class="math inline">\(y_t\)</span>. I’m going to have that same structure where this is normal, <span class="math inline">\(m_t C_t\)</span>. And my <span class="math inline">\(m_t\)</span> using normal theory, again, is going to be <span class="math inline">\(a_t + \sigma_{22}^{-1}\)</span>. And then I have <span class="math inline">\(y_t - f_t\)</span>. So that’s my mean and my covariance matrix. It’s going to be <span class="math inline">\(R_t - q_t^{-1}\)</span> and then I have this transpose again. So if we simplify things a bit here and we call <span class="math inline">\(e_t\)</span>, it’s just the error that we make when we compare <span class="math inline">\(y_t\)</span>, which is the observation with the prediction, right? And then I also use the notation I call <span class="math inline">\(a_t\)</span>, let’s call here <span class="math inline">\(A_t R_t F_t q_t^{-1}\)</span>. Then we can write this down, to mean, we can write as <span class="math inline">\(a_t + A_t\)</span>. And the covariance matrix. We can write it as <span class="math inline">\(R_t, A_t q_t A_t'\)</span>. So this gives me the posterior mean after receiving this <span class="math inline">\(y_t\)</span> observation. And you can see that you can write down the posterior mean, has this usual form of the prior plus something that relates to the error that I make with the prediction. So the <span class="math inline">\(y_t\)</span> appears there and then is weighted by this quantity that we just call <span class="math inline">\(a_t\)</span>. And for the covariance structure, we are also incorporating information about the prior and what the <span class="math inline">\(y_t\)</span> observation provides. So this gives us our filtering equation for <span class="math inline">\(\theta_t\)</span> given <span class="math inline">\(D_t\)</span>. And now we can apply all these equations as we receive observations from <span class="math inline">\(t = 1\)</span> all the way to <span class="math inline">\(T\)</span>. If we happen to have <span class="math inline">\(T\)</span> observations in the time series, we can do this filtering process and obtain these distributions as we receive information.</p>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>