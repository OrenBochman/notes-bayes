{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"dists\"\n",
        "---\n",
        "\n",
        "# CMF\n"
      ],
      "id": "2545d831"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import bokeh.io\n",
        "bokeh.io.output_notebook(hide_banner=True)\n",
        "\n",
        "import numpy as np\n",
        "import scipy.stats as st\n",
        "import scipy.special\n",
        "\n",
        "import bokeh.plotting\n",
        "import bokeh.application\n",
        "import bokeh.application.handlers\n",
        "\n",
        "\n",
        "x = np.arange(0, 11)\n",
        "x_size = x[-1] - x[0]\n",
        "x_c = np.empty(2*len(x))\n",
        "x_c[::2] = x\n",
        "x_c[1::2] = x\n",
        "x_c = np.concatenate(((max(x[0] - 0.05*x_size, x[0] - 0.95),), \n",
        "                      x_c,\n",
        "                      (min(x[-1] + 0.05*x_size, x[-1] + 0.95),)))\n",
        "x_cdf = np.concatenate(((x_c[0],), x))\n",
        "\n",
        "y = st.binom.cdf(x_cdf, 10, 0.5)\n",
        "y_c = np.empty_like(x_c)\n",
        "y_c[::2] = y\n",
        "y_c[1::2] = y\n",
        "\n",
        "p = bokeh.plotting.figure(min_height=250,\n",
        "                          min_width=350,\n",
        "                          x_axis_label='n',\n",
        "                          y_axis_label='F(n; 10, 0.5)')\n",
        "p.line(x_c, y_c, line_width=2)\n",
        "bokeh.io.show(p)"
      ],
      "id": "f9da9cfe",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# CMF\n"
      ],
      "id": "1ec0a5b0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "bokeh.io.output_notebook(hide_banner=True)\n",
        "x = np.arange(0, 11)\n",
        "y = st.binom.cdf(x, 10, 0.5)\n",
        "\n",
        "p = bokeh.plotting.figure(min_height=250,\n",
        "                          min_width=350,\n",
        "                          x_axis_label='n',\n",
        "                          y_axis_label='F(n; 10, 0.5)')\n",
        "p.segment(x[:-1], y[:-1], x[1:], y[:-1], line_width=2)\n",
        "p.ray(0, 0, angle=np.pi, length=0, line_width=2)\n",
        "p.ray(x[-1], 1, angle=0, length=0, line_width=2)\n",
        "p.circle([0], [0], fill_color='white')\n",
        "p.circle(x[1:], y[:-1], fill_color='white')\n",
        "p.circle(x, y)\n",
        "bokeh.io.show(p)"
      ],
      "id": "b1217c6e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Linked plots\n"
      ],
      "id": "f9a4275b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from bokeh.layouts import gridplot\n",
        "from bokeh.models import ColumnDataSource\n",
        "from bokeh.plotting import figure, show\n",
        "from bokeh.sampledata.penguins import data\n",
        "from bokeh.transform import factor_cmap\n",
        "bokeh.io.output_notebook(hide_banner=True)\n",
        "\n",
        "SPECIES = sorted(data.species.unique())\n",
        "\n",
        "TOOLS = \"box_select,lasso_select,help\"\n",
        "\n",
        "source = ColumnDataSource(data)\n",
        "\n",
        "left = figure(width=300, height=400, title=None, tools=TOOLS,\n",
        "              background_fill_color=\"#fafafa\")\n",
        "left.scatter(\"bill_length_mm\", \"body_mass_g\", source=source,\n",
        "             color=factor_cmap('species', 'Category10_3', SPECIES))\n",
        "\n",
        "right = figure(width=300, height=400, title=None, tools=TOOLS,\n",
        "               background_fill_color=\"#fafafa\", y_axis_location=\"right\")\n",
        "right.scatter(\"bill_depth_mm\", \"body_mass_g\", source=source,\n",
        "              color=factor_cmap('species', 'Category10_3', SPECIES))\n",
        "\n",
        "show(gridplot([[left, right]]))"
      ],
      "id": "b7c06173",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import scipy.stats as st\n",
        "\n",
        "from bokeh.plotting import figure, show\n",
        "bokeh.io.output_notebook(hide_banner=True)\n",
        "\n",
        "rng = np.random.default_rng()\n",
        "x = rng.normal(loc=0, scale=1, size=1000)\n",
        "\n",
        "p = figure(width=670, height=400, toolbar_location=None,\n",
        "           title=\"Normal (Gaussian) Distribution\")\n",
        "\n",
        "# Histogram\n",
        "bins = np.linspace(-3, 3, 40)\n",
        "hist, edges = np.histogram(x, density=True, bins=bins)\n",
        "p.quad(top=hist, bottom=0, left=edges[:-1], right=edges[1:],\n",
        "         fill_color=\"skyblue\", line_color=\"white\",\n",
        "         legend_label=\"1000 random samples\")\n",
        "\n",
        "# Probability density function\n",
        "x = np.linspace(-3.0, 3.0, 100)\n",
        "pdf = np.exp(-0.5*x**2) / np.sqrt(2.0*np.pi)\n",
        "p.line(x, pdf, line_width=2, line_color=\"navy\",\n",
        "       legend_label=\"Probability Density Function\")\n",
        "\n",
        "p.y_range.start = 0\n",
        "p.xaxis.axis_label = \"x\"\n",
        "p.yaxis.axis_label = \"PDF(x)\"\n",
        "\n",
        "show(p)"
      ],
      "id": "14dd647a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{javascript}\n",
        "\n",
        "function betacf(x, a, b) {\n",
        "    // From Andreas Madsen's mathfn, Copyright (c) 2013 Andreas Madsen\n",
        "    // Computes incomplete beta function as a continues fraction\n",
        "    var fpmin = 1e-30,\n",
        "        m = 1,\n",
        "        m2, aa, c, d, del, h, qab, qam, qap;\n",
        "    // These q's will be used in factors that occur in the coefficients\n",
        "    qab = a + b;\n",
        "    qap = a + 1;\n",
        "    qam = a - 1;\n",
        "    c = 1;\n",
        "    d = 1 - qab * x / qap;\n",
        "    if (Math.abs(d) < fpmin) d = fpmin;\n",
        "    d = 1 / d;\n",
        "    h = d;\n",
        "    for (; m <= 100; m++) {\n",
        "        m2 = 2 * m;\n",
        "        aa = m * (b - m) * x / ((qam + m2) * (a + m2));\n",
        "        // One step (the even one) of the recurrence\n",
        "        d = 1 + aa * d;\n",
        "        if (Math.abs(d) < fpmin) d = fpmin;\n",
        "        c = 1 + aa / c;\n",
        "        if (Math.abs(c) < fpmin) c = fpmin;\n",
        "        d = 1 / d;\n",
        "        h *= d * c;\n",
        "        aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));\n",
        "        // Next step of the recurrence (the odd one)\n",
        "        d = 1 + aa * d;\n",
        "        if (Math.abs(d) < fpmin) d = fpmin;\n",
        "        c = 1 + aa / c;\n",
        "        if (Math.abs(c) < fpmin) c = fpmin;\n",
        "        d = 1 / d;\n",
        "        del = d * c;\n",
        "        h *= del;\n",
        "        if (Math.abs(del - 1.0) < 3e-7) break;\n",
        "    }\n",
        "    return h;\n",
        "}\n",
        "\n",
        "\n",
        "function regularized_incomplete_beta(x, a, b) {\n",
        "    // From Andreas Madsen's mathfn, Copyright (c) 2013 Andreas Madsen\n",
        "    // Computes incomplete beta function as a continued fraction\n",
        "    if (x < 0 || x > 1) {\n",
        "        throw new RangeError('First argument must be between 0 and 1.');\n",
        "    }\n",
        "\n",
        "    // Special cases, there can make trouble otherwise\n",
        "    else if (a === 1 && b === 1) return x;\n",
        "    else if (x === 0) return 0;\n",
        "    else if (x === 1) return 1;\n",
        "    else if (a === 0) return 1;\n",
        "    else if (b === 0) return 0;\n",
        "\n",
        "    else {\n",
        "        var bt = Math.exp(lngamma(a + b) - lngamma(a) - lngamma(b) + a * Math.log(x) + b * log1p(-x));\n",
        "\n",
        "        // Use continued fraction directly.\n",
        "        if (x < (a + 1) / (a + b + 2)) return bt * betacf(x, a, b) / a;\n",
        "\n",
        "        // else use continued fraction after making the symmetry transformation.\n",
        "        else return 1 - bt * betacf(1 - x, b, a) / b;\n",
        "    }\n",
        "}\n",
        "\n",
        "\n",
        "function incomplete_beta(x, a, b) {\n",
        "    return regularized_incomplete_beta(x, a, b) * Math.exp(lnbeta(a, b));\n",
        "}\n",
        "```"
      ],
      "id": "bcdefff4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import scipy.special\n",
        "import scipy.stats as st\n",
        "\n",
        "\n",
        "from bokeh.layouts import gridplot\n",
        "from bokeh.plotting import figure, show\n",
        "bokeh.io.output_notebook(hide_banner=True)\n",
        "\n",
        "\n",
        "def make_plot(title, hist, edges, x, pdf, cdf):\n",
        "    p = figure(title=title, tools='', background_fill_color=\"#fafafa\")\n",
        "    p.quad(top=hist, bottom=0, left=edges[:-1], right=edges[1:],\n",
        "           fill_color=\"navy\", line_color=\"white\", alpha=0.5)\n",
        "    p.line(x, pdf, line_color=\"#ff8888\", line_width=4, alpha=0.7, legend_label=\"PDF\")\n",
        "    p.line(x, cdf, line_color=\"orange\", line_width=2, alpha=0.7, legend_label=\"CDF\")\n",
        "\n",
        "    p.y_range.start = 0\n",
        "    p.legend.location = \"center_right\"\n",
        "    p.legend.background_fill_color = \"#fefefe\"\n",
        "    p.xaxis.axis_label = 'x'\n",
        "    p.yaxis.axis_label = 'Pr(x)'\n",
        "    p.grid.grid_line_color=\"white\"\n",
        "    return p\n",
        "\n",
        "# Normal Distribution\n",
        "\n",
        "mu, sigma = 0, 0.5\n",
        "\n",
        "measured = np.random.normal(mu, sigma, 1000)\n",
        "hist, edges = np.histogram(measured, density=True, bins=50)\n",
        "\n",
        "x = np.linspace(-2, 2, 1000)\n",
        "pdf = 1/(sigma * np.sqrt(2*np.pi)) * np.exp(-(x-mu)**2 / (2*sigma**2))\n",
        "cdf = (1+scipy.special.erf((x-mu)/np.sqrt(2*sigma**2)))/2\n",
        "\n",
        "p1 = make_plot(\"Normal Distribution (μ=0, σ=0.5)\", hist, edges, x, pdf, cdf)\n",
        "show(gridplot([p1], ncols=1, width=400, height=400, toolbar_location=None))"
      ],
      "id": "485f65ee",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# LogNormal"
      ],
      "id": "f5bf8003"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "bokeh.io.output_notebook(hide_banner=True)\n",
        "\n",
        "# Log-Normal Distribution\n",
        "\n",
        "mu, sigma = 0, 0.5\n",
        "\n",
        "measured = np.random.lognormal(mu, sigma, 1000)\n",
        "hist, edges = np.histogram(measured, density=True, bins=50)\n",
        "\n",
        "x = np.linspace(0.0001, 8.0, 1000)\n",
        "pdf = 1/(x* sigma * np.sqrt(2*np.pi)) * np.exp(-(np.log(x)-mu)**2 / (2*sigma**2))\n",
        "cdf = (1+scipy.special.erf((np.log(x)-mu)/(np.sqrt(2)*sigma)))/2\n",
        "\n",
        "p2 = make_plot(\"Log Normal Distribution (μ=0, σ=0.5)\", hist, edges, x, pdf, cdf)\n",
        "show(gridplot([p2], ncols=1, width=400, height=400, toolbar_location=None))"
      ],
      "id": "0de0d91c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Gamma\n",
        "\n",
        "The exponential distribution predicts the wait time until the *very first* event. The gamma distribution, on the other hand, predicts the wait time until the *k-th* event occurs.\n",
        "\n",
        "The amount of time we have to wait for α  arrivals of a Poisson process. More concretely, if we have events, $X_1 , X_2 , …, X_α$ that are exponentially distributed, $X_1+X_2+⋯+X_α$  is Gamma distributed.\n",
        "\n",
        "## Example\n",
        "Any multi-step process where each step happens at the same rate. This is common in molecular rearrangements.\n",
        "\n",
        "## [Gamma1](http://www.probonto.org/ontology#PROB_k0000572) shape, scale prameterization\n",
        "\n",
        "- shape ($k < 0$), \n",
        "- scale ($\\theta > 0$)\n",
        "- Variance $$\\mathbb{V}ar[Gamma_1|k,\\theta] = k \\theta^2$${#eq-gamma2-pdf}\n",
        "- PDF $$\\frac{1}{\\Gamma(k) \\theta^k} x^{k \\,-\\, 1}e^{-\\frac{x}{\\theta}}$${#eq-gamma1-pdf}\n",
        "- CDF $$\\frac{1}{\\Gamma(k)} \\gamma\\left(k,\\, \\frac{x}{\\theta}\\right)$${#eq-gamma1-cdf}\n",
        "- SF $$1 - \\frac{\\Gamma(\\beta,x/\\alpha)}{\\Gamma(\\beta)}$${#eq-gamma1-sf}\n",
        "- mode $$(k \\,-\\, 1)\\theta \\text{ for } k \\;{\\geq}\\; 1$${#eq-gamma1-mode}\n",
        "- median $$\\text{No simple closed form}$${#eq-gamma1-median}\n",
        "- mean $$k \\theta$${#eq-gamma1-mean}\n",
        "\n",
        "\n",
        "For (k, θ) parameterization: θ is a reciprocal of the event rate λ, which is the mean wait time (the average time between event arrivals).\n",
        "\n",
        "\n",
        "## [Gamma2](http://www.probonto.org/ontology#PROB_k0000598) shape rate prameterization\n",
        "\n",
        "- shape ($\\alpha > 0$), \n",
        "- rate ($\\beta > 0$)\n",
        "- PDF $$\\frac{\\mu^r x^{r-1} e^{-\\mu x}}{\\Gamma(r)}$${#eq-gamma2-pdf}\n",
        "- CDF\n",
        "- Var\n",
        "\n",
        "For (α, β) parameterization: Using our notation k (the # of events) & λ (the rate of events), simply substitute α with k, β with λ. The PDF stays the same format as what we’ve derived.\n"
      ],
      "id": "be367111"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "bokeh.io.output_notebook(hide_banner=True)\n",
        "\n",
        "# Gamma Distribution\n",
        "\n",
        "k, theta = 7.5, 1.0\n",
        "\n",
        "measured = np.random.gamma(k, theta, 1000)\n",
        "hist, edges = np.histogram(measured, density=True, bins=50)\n",
        "\n",
        "x = np.linspace(0.0001, 20.0, 1000)\n",
        "pdf = x**(k-1) * np.exp(-x/theta) / (theta**k * scipy.special.gamma(k))\n",
        "cdf = scipy.special.gammainc(k, x/theta)\n",
        "\n",
        "p3 = make_plot(\"Gamma Distribution (k=7.5, θ=1)\", hist, edges, x, pdf, cdf)\n",
        "show(gridplot([p3], ncols=1, width=400, height=400, toolbar_location=None))"
      ],
      "id": "e26c19a2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from scipy.stats import gamma\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "def plot_gamma_k():\n",
        "    \"\"\"\n",
        "    k : the number of events for which you are waiting to occur.\n",
        "    λ : the rate of events happening following Poisson dist.\n",
        "    \"\"\"\n",
        "    x = np.linspace(0, 50, 1000)\n",
        "    a_values=[1.,2.,3.,5., 9.,7.5,0.5]\n",
        "    b_values=[2.,2.,2.,1.,0.5,1. ,1.]\n",
        "    plt.title(\"PDF of Gamma Distribution\")\n",
        "    plt.xlabel(\"T\")\n",
        "    plt.ylabel(\"Probability Density\")\n",
        "    colors = plt.cm.Pastel1(np.linspace(0, 1, len(a_values)))\n",
        "    colors = plt.cm.rainbow(np.linspace(0, 1, len(a_values)))\n",
        "\n",
        "    for i,z in enumerate(zip(a_values,b_values)): \n",
        "      a,b = z\n",
        "      #mean, var, skew, kurt = gamma.stats(a, moments='mvsk')\n",
        "      y = gamma.pdf(x, a=a,scale=b)\n",
        "      plt.plot(x, y, label=f\"k={a}, θ={b}\", color=colors[i])\n",
        "      plt.legend(bbox_to_anchor=(1, 1), loc='upper right',\n",
        "               borderaxespad=1, fontsize=12)\n",
        "    plt.ylim([0, 0.50])\n",
        "    plt.xlim([0, 20])\n",
        "    plt.show()\n",
        "    plt.savefig('gamma_k.png')\n",
        "    plt.clf()\n",
        "\n",
        "plot_gamma_k()"
      ],
      "id": "614b99c5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def plot_gamma_lambda():\n",
        "    \"\"\"\n",
        "    k : the number of events for which you are waiting to occur.\n",
        "    λ : the rate of events happening following Poisson dist.\n",
        "    \"\"\"\n",
        "    a = 10  # k = 10\n",
        "    x = np.linspace(0, 50, 1000)\n",
        "    import matplotlib as mpl\n",
        "\n",
        "    #colors = ['gold','burlywood','darkorange']\n",
        "    plt.title(\"PDF of Gamma Distribution (k = 10)\")\n",
        "    plt.xlabel(\"T\")\n",
        "    plt.ylabel(\"Probability Density\")\n",
        "    lambdas = [1,2,3]\n",
        "    #colors = plt.cm.rainbow(np.linspace(0, 1, len(lambdas)))\n",
        "    colors = plt.cm.Pastel1(np.linspace(0, 1, len(lambdas)))\n",
        "    for i,lambda_  in enumerate(lambdas):\n",
        "      #mean, var, skew, kurt = gamma.stats(a, scale=1/lambda_, moments='mvsk')\n",
        "      y = gamma.pdf(x, a, scale=1/lambda_)\n",
        "      plt.plot(x, y, label=f\"λ = {lambda_}\", color=colors[i])\n",
        "    plt.legend(bbox_to_anchor=(1, 1), loc='upper right', borderaxespad=1, fontsize=12)\n",
        "    plt.ylim([0, 0.40])\n",
        "    plt.xlim([0, 20])\n",
        "    plt.show()\n",
        "    plt.savefig('gamma_lambda.png')\n",
        "    plt.clf()\n",
        "\n",
        "\n",
        "_=plot_gamma_lambda()"
      ],
      "id": "7986f30a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Beta Distribution\n",
        "\n",
        "\n",
        "Say you wait for two multi-step processes to happen. The individual steps of each process happen at the same rate, but the first multi-step process requires $α$ steps and the second requires $β$  steps. The fraction of the total waiting time take by the first process is Beta distributed.\n",
        "\n",
        "## Examples:\n",
        "\n",
        "1. The Beta Distribution can be used for representing the different probabilities as follows:\n",
        "\n",
        "2. The likelihood of the audience rating the new movie release.\n",
        "3. The click-through rate of the website, which is the proportion of visitors.\n",
        "4. The conversion rate for buyers actually purchasing from your website.\n",
        "5. The  survival chance of a person having blood cancer."
      ],
      "id": "96fda283"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#from numpy.random import default_rng\n",
        "bokeh.io.output_notebook(hide_banner=True)\n",
        "# Beta Distribution\n",
        "\n",
        "story= \"\"\"Say you wait for two multistep Poisson processes to arive. The individual steps of each process happen at the same rate, but the first multistep process requires alpha steps and the second requires beta \n",
        " steps. The fraction of the total waiting time taken by the first process is Beta distributed.\"\"\"\n",
        "\n",
        "alpha, beta = 2, 3\n",
        "# Do this (new version)\n",
        "measured = np.random.default_rng().beta(alpha, beta, size=10000)\n",
        "hist, edges = np.histogram(measured, density=True, bins=50)\n",
        "param_vals={'alpha':1,'beta':1}\n",
        "x = np.linspace(0.0001, 0.999, 1000)\n",
        "#pdf = x**(k-1) * np.exp(-x/theta) / (theta**k * scipy.special.gamma(k))\n",
        "rv = st.beta(alpha, beta)\n",
        "pdf = rv.pdf(x)##st.beta.pdf(x,*param_vals)\n",
        "cdf = rv.cdf(x)##st.beta.cdf(x,*param_vals)\n",
        "\n",
        "p4 = make_plot(\"Beta Distribution (alpha=1, beta=1)\", hist, edges, x, pdf, cdf)\n",
        "show(gridplot([p4], ncols=1, width=400, height=400, toolbar_location=None))"
      ],
      "id": "b2cf51f7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Weibull Distribution\n",
        "\n",
        "Distribution of $x = y^\\beta$ if $y\\sim exp()$. For $\\beta > 1$, the longer we have waited, the more likely the event is to come, and vice versa for $\\beta$\n",
        ".\n",
        "Example. This is a model for aging. The longer an organism lives, the more likely it is to die."
      ],
      "id": "b43487ce"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "bokeh.io.output_notebook(hide_banner=True)\n",
        "# Weibull Distribution\n",
        "\n",
        "lam, k = 1, 1.25\n",
        "measured = lam*(-np.log(np.random.uniform(0, 1, 1000)))**(1/k)\n",
        "hist, edges = np.histogram(measured, density=True, bins=50)\n",
        "\n",
        "x = np.linspace(0.1, 8, 1000)\n",
        "pdf = (k/lam)*(x/lam)**(k-1) * np.exp(-(x/lam)**k)\n",
        "cdf = 1 - np.exp(-(x/lam)**k)\n",
        "p5 = make_plot(\"Weibull Distribution (λ=1, k=1.25)\", hist, edges, x, pdf, cdf)\n",
        "\n",
        "show(gridplot([p5], ncols=2, width=400, height=400, toolbar_location=None))"
      ],
      "id": "df3f76cb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Pareto Distribution\n",
        "\n",
        "Say you wait for two multistep Poisson processes to arive. The individual steps of each process happen at the same rate, but the first multistep process requires alpha steps and the second requires beta  steps. The fraction of the total waiting time taken by the first process is Beta distributed.\n",
        "\n",
        "\n",
        "## Example \n",
        "\n",
        "- The Gutenberg-Richter Law says that the magnitudes of earthquakes in a given region are Pareto distributed. \n",
        "- size of human settlement (many small towns, a few huge cities), \n",
        "- income distribution (many poor, few obscenely rich).\n"
      ],
      "id": "3915cb31"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "bokeh.io.output_notebook(hide_banner=True)\n",
        "from scipy.stats import pareto\n",
        "\n",
        "# Pareto Distribution\n",
        "\n",
        "story= \"\"\"Say you wait for two multistep Poisson processes to arive. The individual steps of each process happen at the same rate, but the first multistep process requires alpha steps and the second requires beta  steps. The fraction of the total waiting time taken by the first process is Beta distributed.\"\"\"\n",
        "\n",
        "b = 2.62\n",
        "rv = st.pareto(b)\n",
        "# Do this (new version)\n",
        "#measured = np.random.default_rng().pareto(b, size=1000)\n",
        "measured = pareto.rvs(b, size=1000)\n",
        "\n",
        "hist, edges = np.histogram(measured, density=True, bins=50)\n",
        "param_vals={'alpha':1,'beta':1}\n",
        "x = np.linspace(pareto.ppf(0.01, b), pareto.ppf(0.99, b), 100)\n",
        "pdf = rv.pdf(x)\n",
        "cdf = rv.cdf(x)\n",
        "\n",
        "p6 = make_plot(f\"Pareto Distribution (b={b})\", hist, edges, x, pdf, cdf)\n",
        "show(gridplot([p6], ncols=1, width=400, height=400, toolbar_location=None))"
      ],
      "id": "e43c321f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Generlized Pareto\n",
        "\n",
        "In statistics, the Generalized Pareto Distribution (GPD) is a family of continuous probability distributions. It is often used to model the tails of another distribution. It is specified by three parameters: location $\\mu$ , scale $\\sigma$ , and shape $\\x_i$\n"
      ],
      "id": "398e9840"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "bokeh.io.output_notebook(hide_banner=True)\n",
        "from scipy.stats import genpareto\n",
        "\n",
        "# Gen Pareto Distribution\n",
        "c = 0.1\n",
        "rv = st.genpareto(c)\n",
        "# Do this (new version)\n",
        "measured = genpareto.rvs(c, size=1000)\n",
        "\n",
        "hist, edges = np.histogram(measured, density=True, bins=50)\n",
        "x = np.linspace(genpareto.ppf(0.01, c), genpareto.ppf(0.99, c), 1000)\n",
        "pdf = rv.pdf(x)\n",
        "cdf = rv.cdf(x)\n",
        "\n",
        "p6 = make_plot(f\"Gen. Pareto Distribution (b={b})\", hist, edges, x, pdf, cdf)\n",
        "show(gridplot([p6], ncols=1, width=400, height=400, toolbar_location=None))"
      ],
      "id": "73b10f1e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Student t\n",
        "\n",
        "In statistics, the Generalized Pareto Distribution (GPD) is a family of continuous probability distributions. It is often used to model the tails of another distribution. It is specified by three parameters: location $\\mu$ , scale $\\sigma$ , and shape $\\x_i$\n",
        "\n",
        "$$\\begin{aligned}\n",
        "f(y \\mid \\nu, \\mu, \\sigma) = \\frac{\\Gamma\\left(\\frac{\\nu+1}{2}\\right)}{\\Gamma\\left(\\frac{\\nu}{2}\\right)\\sqrt{\\pi \\nu \\sigma^2}}\\left(1 + \\frac{(y-\\mu)^2}{\\nu \\sigma^2}\\right)^{-\\frac{\\nu + 1}{2}}.\n",
        "\\end{aligned}$${#eq-t-pdf}\n"
      ],
      "id": "9526bb7d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "bokeh.io.output_notebook(hide_banner=True)\n",
        "from scipy.stats import t\n",
        "\n",
        "# Gen Pareto Distribution\n",
        "nu=2 #df\n",
        "mu=0.0 #loc\n",
        "sigma=1.0 # scale\n",
        "rv = st.t(df=nu,loc=mu,scale=sigma)\n",
        "# Do this (new version)\n",
        "measured = t.rvs(df=nu,loc=mu,scale=sigma, size=1000)\n",
        "\n",
        "hist, edges = np.histogram(measured, density=True, bins=50)\n",
        "x = np.linspace(t.ppf(0.01, df=nu,loc=mu,scale=sigma), t.ppf(0.99, df=nu,loc=mu,scale=sigma), 1000)\n",
        "pdf = rv.pdf(x)\n",
        "cdf = rv.cdf(x)\n",
        "\n",
        "p7 = make_plot(f\"Student-t (nu={nu},mu={mu},sigma={sigma})\", hist, edges, x, pdf, cdf)\n",
        "show(gridplot([p7], ncols=1, width=400, height=400, toolbar_location=None))"
      ],
      "id": "3a919238",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Normal Distribution\n"
      ],
      "id": "faa2eb49"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| fig-column: screen-inset-right\n",
        "#| fig-align: center \n",
        "import numpy as np\n",
        "import scipy.special\n",
        "\n",
        "from bokeh.layouts import gridplot\n",
        "from bokeh.plotting import figure, show\n",
        "from bokeh.models import CustomJS, Slider, TextInput,NumericInput\n",
        "from bokeh.layouts import column, row\n",
        "bokeh.io.output_notebook(hide_banner=True)\n",
        "\n",
        "# Normal Distribution\n",
        "\n",
        "mu, sigma = 0, 0.5\n",
        "\n",
        "def make_plot(title, source, kind=[]):\n",
        "    p = figure(title=title, tools='', background_fill_color=\"#fafafa\")\n",
        "    if 'pdf' in kind : \n",
        "      p.line('x', 'pdf', source=source, line_color=\"#ff8888\", line_width=4, alpha=0.7, legend_label=\"PDF\")\n",
        "    if 'cdf' in kind :\n",
        "      p.line('x', 'cdf', source=source, line_color=\"orange\", line_width=4, alpha=0.7, legend_label=\"CDF\")\n",
        "\n",
        "    p.y_range.start = 0\n",
        "    p.legend.location = \"center_right\"\n",
        "    p.legend.background_fill_color = \"#fefefe\"\n",
        "    p.xaxis.axis_label = 'x'\n",
        "    p.yaxis.axis_label = 'Pr(x)'\n",
        "    p.grid.grid_line_color=\"white\"\n",
        "    return p\n",
        "\n",
        "x = np.linspace(-2, 2, 1000)\n",
        "measured = np.random.normal(mu, sigma, 1000)\n",
        "pdf = 1/(sigma * np.sqrt(2*np.pi)) * np.exp(-(x-mu)**2 / (2*sigma**2))\n",
        "cdf = (1+scipy.special.erf((x-mu)/np.sqrt(2*sigma**2)))/2\n",
        "\n",
        "source = ColumnDataSource(data=dict(x=x, pdf=pdf, cdf=cdf, measured=measured))\n",
        "title = f'Normal Distribution (μ={mu}, σ={sigma})'\n",
        "p_p = make_plot(title=title, source=source, kind=['pdf','hist'] )\n",
        "p_c = make_plot(title=title, source=source, kind=['cdf'])\n",
        "\n",
        "## mu slider\n",
        "mu_slider = Slider(start=-0.5, end=0.5, value=0.0, step=.1, title=\"μ\")\n",
        "sigma_slider = Slider(start=-0.0, end=1.5, value=0.5, step=.1, title=\"σ\")\n",
        "\n",
        "callback = CustomJS(args=dict(source=source,mu_slider=mu_slider,sigma_slider=sigma_slider), code=\"\"\"\n",
        "function gaussianRandom(mean, stdev) {\n",
        "    let u = 1 - Math.random(); // Converting [0,1) to (0,1]\n",
        "    let v = Math.random();\n",
        "    let z = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );\n",
        "    // Transform to the desired mean and standard deviation:\n",
        "    return z * stdev + mean;\n",
        "}\n",
        "\n",
        "function f_pdf(x,mu,sigma){\n",
        " return 1/(sigma * Math.sqrt(2*Math.PI)) * Math.exp(-1*(x-mu)**2 / (2*sigma**2))\n",
        "}\n",
        "\n",
        "function erf(x) {\n",
        "    // Error function using polynomial approximation (accurate to about 10^-7)\n",
        "    var a = [1.00002368,\n",
        "             0.37409196,\n",
        "             0.09678418,\n",
        "             -0.18628806,\n",
        "             0.27886807,\n",
        "             -1.13520398,\n",
        "             1.48851587,\n",
        "             -0.82215223,\n",
        "             0.17087277];\n",
        "\n",
        "    var t = 1 / (1 + Math.abs(x)/2);\n",
        "    var expSum = -Math.pow(x, 2) - 1.26551223;\n",
        "\n",
        "    for (var i = 0; i < a.length; i++) {\n",
        "        expSum += a[i] * Math.pow(t, i+1);\n",
        "    }\n",
        "\n",
        "    var result = 1 - t * Math.exp(expSum);\n",
        "\n",
        "    if (x < 0) return -result;\n",
        "    return result;\n",
        "}\n",
        "\n",
        "function f_cdf(x,mu,sigma){\n",
        " return (1+erf((x-mu)/Math.sqrt(2*sigma**2)))/2\n",
        "}\n",
        "\n",
        "    const mu = mu_slider.value\n",
        "    const sigma = sigma_slider.value\n",
        "    const sdev= Math.sqrt(sigma)\n",
        "    const x = source.data.x\n",
        "    const pdf = Array.from(x, (x) => f_pdf(x, mu,sigma))\n",
        "    const cdf = Array.from(x, (x) => f_cdf(x, mu,sigma))\n",
        "    const measured = Array.from(x, (x) => gaussianRandom(mu,sdev))\n",
        "    source.data = { x, pdf,cdf,measured }\n",
        "\"\"\")\n",
        "mu_slider.js_on_change('value', callback)\n",
        "sigma_slider.js_on_change('value', callback)\n",
        "\n",
        "# todo: update the data when mu changes\n",
        "mu_min_input = NumericInput(value=-1.0,  title=\"min μ\",width=60)\n",
        "mu_min_input.js_link(attr='value',other=mu_slider, other_attr='start')\n",
        "mu_max_input = NumericInput(value=1.0,  title=\"max μ\",width=60)\n",
        "mu_max_input.js_link(attr='value',other=mu_slider, other_attr='end')\n",
        "\n",
        "sigma_min_input = NumericInput(value=0.0,  title=\"min σ\",width=60)\n",
        "sigma_min_input.js_link(attr='value',other=sigma_slider, other_attr='start')\n",
        "sigma_max_input = NumericInput(value=5.0,  title=\"max σ\",width=60)\n",
        "sigma_max_input.js_link(attr='value',other=sigma_slider, other_attr='end')\n",
        "\n",
        "p=gridplot([p_p,bokeh.layouts.Spacer(width=3),p_c], ncols=3, height=400, toolbar_location=None)\n",
        "\n",
        "show(column(\n",
        "  row(mu_min_input,mu_slider,mu_max_input),\n",
        "  row(sigma_min_input,sigma_slider,sigma_max_input),\n",
        "  row(p)\n",
        "  ))"
      ],
      "id": "12cdae84",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# PDF & CDF Interactive titles \n"
      ],
      "id": "0bb1ffc4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| fig-column: screen-inset-right\n",
        "#| fig-align: center \n",
        "import numpy as np\n",
        "import scipy.special\n",
        "\n",
        "from bokeh.layouts import gridplot\n",
        "from bokeh.plotting import figure, show\n",
        "from bokeh.models import CustomJS, Slider, TextInput,NumericInput\n",
        "from bokeh.layouts import column, row\n",
        "bokeh.io.output_notebook(hide_banner=True)\n",
        "\n",
        "# Normal Distribution\n",
        "\n",
        "mu, sigma = 0, 0.5\n",
        "\n",
        "def make_plot(title, source, kind=[]):\n",
        "    p = figure(title=title, tools='', background_fill_color=\"#fafafa\")\n",
        "    if 'pdf' in kind : \n",
        "      p.line('x', 'pdf', source=source, line_color=\"#ff8888\", line_width=4, alpha=0.7, legend_label=\"PDF\")\n",
        "    if 'cdf' in kind :\n",
        "      p.line('x', 'cdf', source=source, line_color=\"orange\", line_width=4, alpha=0.7, legend_label=\"CDF\")\n",
        "\n",
        "    p.y_range.start = 0\n",
        "    p.legend.location = \"center_right\"\n",
        "    p.legend.background_fill_color = \"#fefefe\"\n",
        "    p.xaxis.axis_label = 'x'\n",
        "    p.yaxis.axis_label = 'Pr(x)'\n",
        "    p.grid.grid_line_color=\"white\"\n",
        "    return p\n",
        "\n",
        "x = np.linspace(-2, 2, 1000)\n",
        "measured = np.random.normal(mu, sigma, 1000)\n",
        "pdf = 1/(sigma * np.sqrt(2*np.pi)) * np.exp(-(x-mu)**2 / (2*sigma**2))\n",
        "cdf = (1+scipy.special.erf((x-mu)/np.sqrt(2*sigma**2)))/2\n",
        "\n",
        "source = ColumnDataSource(data=dict(x=x, pdf=pdf, cdf=cdf, measured=measured))\n",
        "title = f'Normal Distribution (μ={mu}, σ={sigma})'\n",
        "p_p = make_plot(title=title, source=source, kind=['pdf','hist'] )\n",
        "p_c = make_plot(title=title, source=source, kind=['cdf'])\n",
        "\n",
        "## mu slider\n",
        "mu_slider = Slider(start=-0.5, end=0.5, value=0.0, step=.1, title=\"μ\")\n",
        "sigma_slider = Slider(start=-0.0, end=1.5, value=0.5, step=.1, title=\"σ\")\n",
        "\n",
        "callback = CustomJS(args=dict(source=source, mu_slider=mu_slider, sigma_slider=sigma_slider, p_p=p_p, p_c=p_c), code=\"\"\"\n",
        "function gaussianRandom(mean, stdev) {\n",
        "    let u = 1 - Math.random(); // Converting [0,1) to (0,1]\n",
        "    let v = Math.random();\n",
        "    let z = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );\n",
        "    // Transform to the desired mean and standard deviation:\n",
        "    return z * stdev + mean;\n",
        "}\n",
        "\n",
        "function f_pdf(x,mu,sigma){\n",
        " return 1/(sigma * Math.sqrt(2*Math.PI)) * Math.exp(-1*(x-mu)**2 / (2*sigma**2))\n",
        "}\n",
        "\n",
        "function erf(x) {\n",
        "    // Error function using polynomial approximation (accurate to about 10^-7)\n",
        "    var a = [1.00002368,\n",
        "             0.37409196,\n",
        "             0.09678418,\n",
        "             -0.18628806,\n",
        "             0.27886807,\n",
        "             -1.13520398,\n",
        "             1.48851587,\n",
        "             -0.82215223,\n",
        "             0.17087277];\n",
        "\n",
        "    var t = 1 / (1 + Math.abs(x)/2);\n",
        "    var expSum = -Math.pow(x, 2) - 1.26551223;\n",
        "\n",
        "    for (var i = 0; i < a.length; i++) {\n",
        "        expSum += a[i] * Math.pow(t, i+1);\n",
        "    }\n",
        "\n",
        "    var result = 1 - t * Math.exp(expSum);\n",
        "\n",
        "    if (x < 0) return -result;\n",
        "    return result;\n",
        "}\n",
        "\n",
        "function f_cdf(x,mu,sigma){\n",
        " return (1+erf((x-mu)/Math.sqrt(2*sigma**2)))/2\n",
        "}\n",
        "\n",
        "    const mu = mu_slider.value\n",
        "    const sigma = sigma_slider.value\n",
        "    const sdev= Math.sqrt(sigma)\n",
        "    const x = source.data.x\n",
        "    const pdf = Array.from(x, (x) => f_pdf(x, mu,sigma))\n",
        "    const cdf = Array.from(x, (x) => f_cdf(x, mu,sigma))\n",
        "    const measured = Array.from(x, (x) => gaussianRandom(mu,sdev))\n",
        "    source.data = { x, pdf,cdf,measured }\n",
        "    const title = `Normal Distribution (μ=${mu}, σ=${sigma})`\n",
        "    p_p.title.text = title\n",
        "    p_c.title.text = title\n",
        "\n",
        "\"\"\")\n",
        "mu_slider.js_on_change('value', callback)\n",
        "sigma_slider.js_on_change('value', callback)\n",
        "\n",
        "# todo: update the data when mu changes\n",
        "mu_min_input = NumericInput(value=-1.0,  title=\"min μ\",width=60)\n",
        "mu_min_input.js_link(attr='value',other=mu_slider, other_attr='start')\n",
        "mu_max_input = NumericInput(value=1.0,  title=\"max μ\",width=60)\n",
        "mu_max_input.js_link(attr='value',other=mu_slider, other_attr='end')\n",
        "\n",
        "sigma_min_input = NumericInput(value=0.0,  title=\"min σ\",width=60)\n",
        "sigma_min_input.js_link(attr='value',other=sigma_slider, other_attr='start')\n",
        "sigma_max_input = NumericInput(value=5.0,  title=\"max σ\",width=60)\n",
        "sigma_max_input.js_link(attr='value',other=sigma_slider, other_attr='end')\n",
        "\n",
        "p=gridplot([p_p,bokeh.layouts.Spacer(width=3),p_c], ncols=3, height=400, toolbar_location=None)\n",
        "\n",
        "show(column(\n",
        "  row(mu_min_input,mu_slider,mu_max_input),\n",
        "  row(sigma_min_input,sigma_slider,sigma_max_input),\n",
        "  row(p)\n",
        "  ))"
      ],
      "id": "0ec89077",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Picture\n"
      ],
      "id": "d20be5cc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from bokeh.plotting import figure, show, output_file\n",
        "bokeh.io.output_notebook(hide_banner=True)\n",
        "\n",
        "p = figure(x_range=(0,1), y_range=(0,1))\n",
        "p.image_url(url=['bernoulli.jpg'], x=0, y=1, w=0.8, h=0.6)\n",
        "show(p)"
      ],
      "id": "37053efc",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/home/oren/.local/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}